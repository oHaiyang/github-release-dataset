import _defineProperty from 'babel-runtime/helpers/defineProperty';
import yaml from 'js-yaml';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _regeneratorRuntime from 'babel-runtime/regenerator';
import _extends from 'babel-runtime/helpers/extends';
import _asyncToGenerator from 'babel-runtime/helpers/asyncToGenerator';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import GitHub from '@octokit/rest';

// export for test
var COMMENT = '# GENERATED BY https://github.com/oHaiyang/github-release-dataset, DO NOT MODIFY';
var DATASET_KEY = 'dataset-name';
var YAML_CODE_BLOCK_REG = /```yaml *[\r\n]+([\s\S]*?)[\r\n]+```/gi;

function buildCodeBlock(string) {
  return '```yaml' + '\n' + COMMENT + '\n\n' + string + '\n' + '```';
}

function buildDatasetObj(name, dataset) {
  var _ref;

  return _ref = {}, _defineProperty(_ref, DATASET_KEY, name), _defineProperty(_ref, 'dataset', dataset), _ref;
}

function readDatasets(releaseNote, datasetName) {
  var datasetMatch = void 0;
  var results = [];

  do {
    datasetMatch = YAML_CODE_BLOCK_REG.exec(releaseNote);
    if (datasetMatch) {
      var length = datasetMatch[0].length;
      var start = datasetMatch.index;
      var body = datasetMatch[1];
      var dataset = yaml.load(body);
      var name = dataset[DATASET_KEY];

      // If datasetName are specified, return name matched datasets,
      // otherwise return all datasets
      if (datasetName ? name === datasetName : !!name) {
        results.push({
          start: start,
          length: length,
          name: name,
          body: body,
          dataset: dataset
        });
      }
    }
  } while (datasetMatch);

  return results;
}

function insertIntoNote(note, text, top) {
  if (top) {
    return text + '\n' + note;
  }
  return note + '\n' + text;
}

function getSplicedNote(note, start, length) {
  var text = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

  var nextString = note.slice(0, start);
  nextString += text;
  nextString += note.slice(start + length);
  return nextString;
}

function getNewDataset(newDatasetOrUpdater, oldDataset) {
  if (typeof newDatasetOrUpdater === 'function') {
    return newDatasetOrUpdater(oldDataset);
  }
  return newDatasetOrUpdater;
}

var Smuggler = function () {
  function Smuggler(token, owner, repo) {
    _classCallCheck(this, Smuggler);

    this.target = {
      owner: owner,
      repo: repo
    };

    this.g = GitHub();

    this.g.authenticate({
      type: 'token',
      token: token
    });

    this.releases = {};
  }

  _createClass(Smuggler, [{
    key: 'updateReleaseNote',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tag, releaseNote) {
        var _ref2, id;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref2 = _context.sent;
                id = _ref2.id;
                _context.prev = 4;
                _context.next = 7;
                return this.g.repos.editRelease(_extends({}, this.target, {
                  id: id,
                  tag_name: tag,
                  body: releaseNote
                }));

              case 7:
                if (this.releases[tag]) this.releases[tag].body = releaseNote;
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context['catch'](4);
                throw new Error('Failed to update releaseNote of ' + tag + '. ' + _context.t0.message);

              case 13:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 10]]);
      }));

      function updateReleaseNote(_x, _x2) {
        return _ref.apply(this, arguments);
      }

      return updateReleaseNote;
    }()
  }, {
    key: 'getRelease',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tag) {
        var _ref4, release;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.releases[tag]) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return', this.releases[tag]);

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this.g.repos.getReleaseByTag(_extends({}, this.target, {
                  tag: tag
                }));

              case 5:
                _ref4 = _context2.sent;
                release = _ref4.data;


                this.releases[tag] = release;
                return _context2.abrupt('return', release);

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2['catch'](2);
                throw new Error('Failed to get release ' + tag + '. ' + _context2.t0.message);

              case 14:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 11]]);
      }));

      function getRelease(_x3) {
        return _ref3.apply(this, arguments);
      }

      return getRelease;
    }()
  }, {
    key: 'getDataset',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tag, datasetName) {
        var _ref6, releaseNote, _readDatasets, _readDatasets2, dataset;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref6 = _context3.sent;
                releaseNote = _ref6.body;
                _readDatasets = readDatasets(releaseNote, datasetName), _readDatasets2 = _slicedToArray(_readDatasets, 1), dataset = _readDatasets2[0].dataset;
                return _context3.abrupt('return', dataset);

              case 6:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getDataset(_x4, _x5) {
        return _ref5.apply(this, arguments);
      }

      return getDataset;
    }()
  }, {
    key: 'addDataset',
    value: function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(tag, datasetName, dataset) {
        var insertTop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        var _ref8, releaseNote, results, yamlString, codeBlock;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref8 = _context4.sent;
                releaseNote = _ref8.body;
                results = readDatasets(releaseNote, datasetName);

                if (!(results.length > 0)) {
                  _context4.next = 7;
                  break;
                }

                throw new Error('Dataset named ' + datasetName + ' already exists in ' + tag + ', failed to add.');

              case 7:
                yamlString = yaml.dump(buildDatasetObj(datasetName, dataset));
                codeBlock = buildCodeBlock(yamlString);

                releaseNote = insertIntoNote(releaseNote, codeBlock, insertTop);

                _context4.next = 12;
                return this.updateReleaseNote(tag, releaseNote);

              case 12:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function addDataset(_x6, _x7, _x8) {
        return _ref7.apply(this, arguments);
      }

      return addDataset;
    }()
  }, {
    key: 'updateDataset',
    value: function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(tag, datasetName, datasetOrUpdater) {
        var addIfNotExisting = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var _ref10, releaseNote, _readDatasets3, _readDatasets4, result, newDataset, newDatasetCodeBlock, newReleaseNote;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref10 = _context5.sent;
                releaseNote = _ref10.body;
                _readDatasets3 = readDatasets(releaseNote, datasetName), _readDatasets4 = _slicedToArray(_readDatasets3, 1), result = _readDatasets4[0];

                if (!(!result && !addIfNotExisting)) {
                  _context5.next = 7;
                  break;
                }

                throw new Error('Update dataset ' + datasetName + ' for ' + tag + ' failed, dataset doesn\'t exist.');

              case 7:
                newDataset = getNewDataset(datasetOrUpdater, result && result.dataset);

                if (!(!result && addIfNotExisting)) {
                  _context5.next = 12;
                  break;
                }

                _context5.next = 11;
                return this.addDataset(tag, datasetName, newDataset);

              case 11:
                return _context5.abrupt('return');

              case 12:
                newDatasetCodeBlock = buildCodeBlock(yaml.dump(buildDatasetObj(datasetName, newDataset)));
                newReleaseNote = getSplicedNote(releaseNote, result.start, result.length, newDatasetCodeBlock);
                _context5.next = 16;
                return this.updateReleaseNote(tag, newReleaseNote);

              case 16:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function updateDataset(_x10, _x11, _x12) {
        return _ref9.apply(this, arguments);
      }

      return updateDataset;
    }()
  }, {
    key: 'deleteDataset',
    value: function () {
      var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(tag, datasetName) {
        var _ref12, releaseNote, _readDatasets5, _readDatasets6, firstResult, start, length;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref12 = _context6.sent;
                releaseNote = _ref12.body;


                // Only delete first meeted block
                _readDatasets5 = readDatasets(releaseNote, datasetName), _readDatasets6 = _slicedToArray(_readDatasets5, 1), firstResult = _readDatasets6[0];

                if (!firstResult) {
                  _context6.next = 12;
                  break;
                }

                start = firstResult.start, length = firstResult.length;

                releaseNote = getSplicedNote(releaseNote, start, length);
                _context6.next = 10;
                return this.updateReleaseNote(tag, releaseNote);

              case 10:
                _context6.next = 13;
                break;

              case 12:
                console.warn("Dataset doesn't exist, deletion not performed.");

              case 13:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function deleteDataset(_x14, _x15) {
        return _ref11.apply(this, arguments);
      }

      return deleteDataset;
    }()
  }]);

  return Smuggler;
}();

export default Smuggler;
