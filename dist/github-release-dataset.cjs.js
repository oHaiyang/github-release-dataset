'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var yaml = _interopDefault(require('js-yaml'));
var GitHub = _interopDefault(require('@octokit/rest'));

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

// export for test
var COMMENT = '# GENERATED BY https://github.com/oHaiyang/github-release-dataset, DO NOT MODIFY';
var DATASET_KEY = 'dataset-name';
var YAML_CODE_BLOCK_REG = /```yaml *[\r\n]+([\s\S]*?)[\r\n]+```/gi;

function buildCodeBlock(string) {
  return '```yaml' + '\n' + COMMENT + '\n\n' + string + '\n' + '```';
}

function buildDatasetObj(name, dataset) {
  var _ref;

  return _ref = {}, defineProperty(_ref, DATASET_KEY, name), defineProperty(_ref, 'dataset', dataset), _ref;
}

function readDatasets(releaseNote, datasetName) {
  var datasetMatch = void 0;
  var results = [];

  do {
    datasetMatch = YAML_CODE_BLOCK_REG.exec(releaseNote);
    if (datasetMatch) {
      var length = datasetMatch[0].length;
      var start = datasetMatch.index;
      var body = datasetMatch[1];
      var dataset = yaml.load(body);
      var name = dataset[DATASET_KEY];

      // If datasetName are specified, return name matched datasets,
      // otherwise return all datasets
      if (datasetName ? name === datasetName : !!name) {
        results.push({
          start: start,
          length: length,
          name: name,
          body: body,
          dataset: dataset
        });
      }
    }
  } while (datasetMatch);

  return results;
}

function insertIntoNote(note, text, top) {
  if (top) {
    return text + '\n' + note;
  }
  return note + '\n' + text;
}

function getSplicedNote(note, start, length) {
  var text = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

  var nextString = note.slice(0, start);
  nextString += text;
  nextString += note.slice(start + length);
  return nextString;
}

function getNewDataset(newDatasetOrUpdater, oldDataset) {
  if (typeof newDatasetOrUpdater === 'function') {
    return newDatasetOrUpdater(oldDataset);
  }
  return newDatasetOrUpdater;
}

var Smuggler = function () {
  function Smuggler(token, owner, repo) {
    classCallCheck(this, Smuggler);

    this.target = {
      owner: owner,
      repo: repo
    };

    this.g = GitHub();

    this.g.authenticate({
      type: 'token',
      token: token
    });

    this.releases = {};
  }

  createClass(Smuggler, [{
    key: 'updateReleaseNote',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tag, releaseNote) {
        var _ref2, id;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref2 = _context.sent;
                id = _ref2.id;
                _context.prev = 4;
                _context.next = 7;
                return this.g.repos.editRelease(_extends({}, this.target, {
                  id: id,
                  tag_name: tag,
                  body: releaseNote
                }));

              case 7:
                if (this.releases[tag]) this.releases[tag].body = releaseNote;
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context['catch'](4);
                throw new Error('Failed to update releaseNote of ' + tag + '. ' + _context.t0.message);

              case 13:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 10]]);
      }));

      function updateReleaseNote(_x, _x2) {
        return _ref.apply(this, arguments);
      }

      return updateReleaseNote;
    }()
  }, {
    key: 'getRelease',
    value: function () {
      var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(tag) {
        var _ref4, release;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.releases[tag]) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return', this.releases[tag]);

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this.g.repos.getReleaseByTag(_extends({}, this.target, {
                  tag: tag
                }));

              case 5:
                _ref4 = _context2.sent;
                release = _ref4.data;


                this.releases[tag] = release;
                return _context2.abrupt('return', release);

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2['catch'](2);
                throw new Error('Failed to get release ' + tag + '. ' + _context2.t0.message);

              case 14:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 11]]);
      }));

      function getRelease(_x3) {
        return _ref3.apply(this, arguments);
      }

      return getRelease;
    }()
  }, {
    key: 'getDataset',
    value: function () {
      var _ref5 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(tag, datasetName) {
        var _ref6, releaseNote, _readDatasets, _readDatasets2, dataset;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref6 = _context3.sent;
                releaseNote = _ref6.body;
                _readDatasets = readDatasets(releaseNote, datasetName), _readDatasets2 = slicedToArray(_readDatasets, 1), dataset = _readDatasets2[0].dataset;
                return _context3.abrupt('return', dataset);

              case 6:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getDataset(_x4, _x5) {
        return _ref5.apply(this, arguments);
      }

      return getDataset;
    }()
  }, {
    key: 'addDataset',
    value: function () {
      var _ref7 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(tag, datasetName, dataset) {
        var insertTop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        var _ref8, releaseNote, results, yamlString, codeBlock;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref8 = _context4.sent;
                releaseNote = _ref8.body;
                results = readDatasets(releaseNote, datasetName);

                if (!(results.length > 0)) {
                  _context4.next = 7;
                  break;
                }

                throw new Error('Dataset named ' + datasetName + ' already exists in ' + tag + ', failed to add.');

              case 7:
                yamlString = yaml.dump(buildDatasetObj(datasetName, dataset));
                codeBlock = buildCodeBlock(yamlString);

                releaseNote = insertIntoNote(releaseNote, codeBlock, insertTop);

                _context4.next = 12;
                return this.updateReleaseNote(tag, releaseNote);

              case 12:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function addDataset(_x6, _x7, _x8) {
        return _ref7.apply(this, arguments);
      }

      return addDataset;
    }()
  }, {
    key: 'updateDataset',
    value: function () {
      var _ref9 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(tag, datasetName, datasetOrUpdater) {
        var addIfNotExisting = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var _ref10, releaseNote, _readDatasets3, _readDatasets4, result, newDataset, newDatasetCodeBlock, newReleaseNote;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref10 = _context5.sent;
                releaseNote = _ref10.body;
                _readDatasets3 = readDatasets(releaseNote, datasetName), _readDatasets4 = slicedToArray(_readDatasets3, 1), result = _readDatasets4[0];

                if (!(!result && !addIfNotExisting)) {
                  _context5.next = 7;
                  break;
                }

                throw new Error('Update dataset ' + datasetName + ' for ' + tag + ' failed, dataset doesn\'t exist.');

              case 7:
                newDataset = getNewDataset(datasetOrUpdater, result && result.dataset);

                if (!(!result && addIfNotExisting)) {
                  _context5.next = 12;
                  break;
                }

                _context5.next = 11;
                return this.addDataset(tag, datasetName, newDataset);

              case 11:
                return _context5.abrupt('return');

              case 12:
                newDatasetCodeBlock = buildCodeBlock(yaml.dump(buildDatasetObj(datasetName, newDataset)));
                newReleaseNote = getSplicedNote(releaseNote, result.start, result.length, newDatasetCodeBlock);
                _context5.next = 16;
                return this.updateReleaseNote(tag, newReleaseNote);

              case 16:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function updateDataset(_x10, _x11, _x12) {
        return _ref9.apply(this, arguments);
      }

      return updateDataset;
    }()
  }, {
    key: 'deleteDataset',
    value: function () {
      var _ref11 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(tag, datasetName) {
        var _ref12, releaseNote, _readDatasets5, _readDatasets6, firstResult, start, length;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getRelease(tag);

              case 2:
                _ref12 = _context6.sent;
                releaseNote = _ref12.body;


                // Only delete first meeted block
                _readDatasets5 = readDatasets(releaseNote, datasetName), _readDatasets6 = slicedToArray(_readDatasets5, 1), firstResult = _readDatasets6[0];

                if (!firstResult) {
                  _context6.next = 12;
                  break;
                }

                start = firstResult.start, length = firstResult.length;

                releaseNote = getSplicedNote(releaseNote, start, length);
                _context6.next = 10;
                return this.updateReleaseNote(tag, releaseNote);

              case 10:
                _context6.next = 13;
                break;

              case 12:
                console.warn("Dataset doesn't exist, deletion not performed.");

              case 13:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function deleteDataset(_x14, _x15) {
        return _ref11.apply(this, arguments);
      }

      return deleteDataset;
    }()
  }]);
  return Smuggler;
}();

module.exports = Smuggler;
