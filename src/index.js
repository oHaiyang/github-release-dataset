const GitHub = require('@octokit/rest');
const yaml = require('js-yaml');

const COMMENT =
  '# GENERATED BY https://github.com/oHaiyang/github-release-dataset, DO NOT MODIFY';
const DATASET_KEY = 'dataset-name';
const YAML_CODE_BLOCK_REG = /```yaml *[\r\n]+([\s\S]*?)[\r\n]+```/gi;

class Smuggler {
  constructor(token, owner, repo) {
    this.target = {
      owner,
      repo,
    };

    this.g = GitHub();

    this.g.authenticate({
      type: 'token',
      token,
    });

    this.releases = {};
  }

  buildCodeBlock(string) {
    return '```yaml' + '\n' + COMMENT + '\n\n' + string + '```';
  }

  buildDatasetObj(name, dataset) {
    return {
      [DATASET_KEY]: name,
      dataset,
    };
  }

  async updateReleaseNote(tag, releaseNote) {
    const { id } = await this.getRelease(tag);

    try {
      await this.g.repos.editRelease({
        ...this.target,
        id,
        tag_name: tag,
        body: releaseNote,
      });
      if (this.releases[tag]) this.releases[tag].body = releaseNote;
    } catch (e) {
      throw new Error(`Failed to update releaseNote of ${tag}. ` + e.message);
    }
  }

  async getRelease(tag) {
    if (this.releases[tag]) return this.releases[tag];

    try {
      const { data: release } = await this.g.repos.getReleaseByTag({
        ...this.target,
        tag,
      });

      this.releases[tag] = release;
      return release;
    } catch (e) {
      throw new Error(`Failed to get release ${tag}. ` + e.message);
    }
  }

  readDatasets(releaseNote, datasetName) {
    let datasetMatch;
    let results = [];

    do {
      datasetMatch = YAML_CODE_BLOCK_REG.exec(releaseNote);
      if (datasetMatch) {
        const length = datasetMatch[0].length;
        const start = datasetMatch.index;
        const body = datasetMatch[1];
        const name = yaml.load(body)[DATASET_KEY];

        // If datasetName are specified, return name matched dataset,
        // otherwist return all datasets
        if (datasetName ? name === datasetName : !!name) {
          results.push({
            start,
            length,
            name,
            body,
          });
        }
      }
    } while (datasetMatch);

    return results;
  }

  async addDataset(tag, datasetName, dataset, insertBeforeTop = false) {
    let { body: releaseNote } = await this.getRelease(tag);

    let datasets = this.readDatasets(releaseNote, datasetName);
    if (datasets.length > 0) {
      throw new Error(
        `Dataset named ${datasetName} already exists in ${tag}, failed to add.`
      );
    }

    const yamlString = yaml.dump(this.buildDatasetObj(datasetName, dataset));
    const codeBlock = this.buildCodeBlock(yamlString);
    if (insertBeforeTop) {
      releaseNote = codeBlock + '\n' + releaseNote;
    } else {
      releaseNote = releaseNote + '\n' + codeBlock;
    }

    await this.updateReleaseNote(tag, releaseNote);
  }

  async updateDataset(tag, datasetName, dataset) {}

  async deleteDataset(tag, datasetName) {
    let { body: releaseNote } = await this.getRelease(tag);

    // Only delete first meeted block
    let [firstDataset] = this.readDatasets(releaseNote, datasetName);

    if (firstDataset) {
      const { start, length } = firstDataset;
      releaseNote = releaseNote.slice(0, start) + releaseNote.slice(start + length);
    } else {
      console.warn('Dataset doesn\'t exist, deletion not performed.');
    }

    await this.updateReleaseNote(tag, releaseNote);
  }
}

module.exports = Smuggler;
